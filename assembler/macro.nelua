--[[------------------------------------------
|This file contains code related to creating,|
|manipulating and expending macros.          |
--------------------------------------------]]

--[[
Macros are defined in the following way:
@define <macro_name> <number of args>
    <content>
    <content>
@end

In the macro's content, arguments are accessed by calling $<argument_number>

In assembly, macros are called by doing @<macro_name> <arg1> <arg2> ...

Note: The first argument is accessed with $1

]]

require 'string'
require 'vector'
require 'io'
require 'parser'

----------------------------------Data types------------------------------------

global macro = @record {
    name: string,
    number_of_args: integer,
    content: pure_file,
}

--A list of all the usable macros
local macro_list: vector(macro)

------------------------------Registering macros--------------------------------

--Check that all the arguments in a macro are well formed. For exemple,
--there is no $abcd
local function check_arg_formed_OK(m: macro): boolean
    for i=0,<#m.content do
        local curr_line = m.content[i]
        for j=0,#curr_line do
            local curr_word = curr_line[j]
            if curr_word:sub(1,1) == "$" then --Note: we know for sure that curr_word is at least of length 1
                if #curr_word == 1 then
                    return false
                end
                local arg_num = tointeger(curr_word:sub(2,#curr_word))
                if arg_num < 1 then
                    return  false
                end
            end
        end
    end
    return true
end

--Check that a macro uses all its arguments but only its arguments
--It is assumed that all the argument acces are properly made
local function check_arg_use_OK(m: macro): boolean
    local list_used_args: vector(boolean) --Keeping a record of all used arguments
    for i=0,<#list_used_args do
        list_used_args:push(false)
    end
    for i=0,<#m.content do
        local curr_line = m.content[i]
        for j=0,#curr_line do
            local curr_word = curr_line[j]
            if curr_word:sub(1,1) == "$" then --Note: we know for sure that curr_word is at least of length 1
                local arg_num = tointeger(curr_word:sub(2,#curr_word))
                if arg_num > m.number_of_args then
                    return false
                end
                list_used_args[arg_num-1] = true
            end
        end
    end
    for i=0,<#list_used_args do
        if not list_used_args[i] then
            return false
        end
    end
    return false
end

--Try to register a macro in the macro list. Runs check functions
--to print warnings or errors. Return true if the macro is registered
--or false if it is not.
global function register_macro(name: string, number_of_args: integer, content: pure_file): boolean
    local m: macro
    --Looking for doubles
    for i=0,<#macro_list do
        if macro_list[i].name == name then
            io.stderr:write("Error, a macro with the name ")
            io.stderr:write(name)
            io.stderr:write(" already registered.\n")
            return false
        end
    end
    local try_macro: macro = {name, number_of_args, content}
    --Checking content
    local ret = check_arg_formed_OK(try_macro) and check_arg_use_OK(try_macro)
    --Registering macro
    if ret then
        macro_list:push(try_macro)
    end
    return ret
end

----------------------------------Expending macros------------------------------

--Try to expend a macro from a pure_line of assembly. Return the expended macro
--as a pure_file and also a beelean telling that the expension succeded.
--global function expend_macro(line: pure_line): (pure_file, boolean)
