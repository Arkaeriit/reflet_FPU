--[[--------------------------------------------
|This file contains the main loop of the       |
|assembling, reading a file, checking each     |
|line and either assemble them and process     |
|them like macro or other assembler directives.|
----------------------------------------------]]

--[[
During assembly, the output is represented as a list of assembling blocs.
An assembling block can either be:
    - A pure_file of assembly language associated with name and a start line. The name and start line are used to display error messages that tell the line and the file where the error come from.
    - A label being set or a reference to that label that needs to be computed.
    - A special assembler directive such as an alignment constrain.
    - An assembled instruction in machine code.
    - A raw binary constant

The first two steps of the compilation is to decode all pure_files in the list. The pure_files are processed line by line.

In the first step, the @import directives are extended into new pure_files, the rest of the assembly code is packed into other pure_files. This steps is repeated until there is no longer any @import directives.

The second step is to process other directives
- @define ... @end directives are registered as macro.
- Macro are expended into pure_files.
- @label and @labref are registered
- @align are registered
- @constant and @rawbytes are registered as such
This step is repeated until there is no longer any pure_files in the list of blocs

The third step is to replace blocks of variable size such as pure_file and rawbytes into blocks of known size such as machine_code and rawbyte blocks.

The fourth step is to replace all the blocs whose size are not known yet (alignment directives) with blocks of padding whose size is known. Furthermore, machine code blocks are replaced with two rawbyte blocks.

As the fifth step, when the address of everything can be known, a linking can be done by replacing @labref with raw constants. Furthermore, @label can be checked to ensure that there is no duplicates.

Lastly, the fifth step is to write the output binary file.

]]

--[[ TODO

- when error encountered in file blocks should tell in which file and
at which line the error happened.
- step 4
- step 5

]]

require 'io'
require 'macro'
require 'vector'
require 'string'
require 'parser'
require 'filestream'
require 'stringbuilder'

----------------------------------- Data types ---------------------------------

local error_t = @enum {
    OK = 0,
    file_read,
    file_write,
    arguments,
    instruction,
    type,
}

local block_types = @enum {
    pure_file = 1,
    machine_code,
    alignment_directive,
    rawbyte,
    rawbytes,
    label
}

local pure_file_block = @record {
    content: pure_file,
    name: string,
    place: integer
}

local machine_code_block = @record {
    code: uint16,
    comment: string
}

local alignment_directive_block = @record {
    byte_alignment: integer
}

local rawbyte_block = @record {
    content: byte
}

local rawbytes_block = @record {
    content: vector(byte)
}

local label_block = @record {
    id: string,
    set: boolean
}

local block_union = @union {
    pure_file: pure_file_block,
    machine_code: machine_code_block,
    alignment_directive: alignment_directive_block,
    rawbyte: rawbyte_block,
    rawbytes: rawbytes_block,
    label: label_block
}

local block = @record {
    type: block_types,
    content: block_union
}

function block:__tostring()
    local builder: stringbuilder
    if self.type == block_types.pure_file then
        builder:write("Type = Pure File\nFilename = ")
        builder:write(self.content.pure_file.name)
        builder:write(" ; place = ")
        builder:write(self.content.pure_file.place)
        builder:write(" ; content = [")
        builder:write(self.content.pure_file.content)
        builder:write("]\n")
    elseif self.type == block_types.label then
        builder:write("Type = Label; ID = ")
        builder:write(self.content.label.id)
        builder:write(" ; set ? ")
        builder:write(self.content.label.set)
        builder:write("\n")
    elseif self.type == block_types.machine_code then
        builder:write("Type = Machine Code; code = ")
        builder:write(self.content.machine_code.code)
        builder:write(" ; detail: ")
        builder:write(self.content.machine_code.comment)
        builder:write("\n")
    elseif self.type == block_types.alignment_directive then
        builder:write("Type = Alignment Directive; align to ")
        builder:write(self.content.alignment_directive.byte_alignment)
        builder:write("bytes\n")
    elseif self.type == block_types.rawbyte then
        builder:write("Type = Raw Byte; value = ")
        builder:write(string.format("0x%02X", self.content.rawbyte.content))
        builder:write("\n")
    else
        builder:write("Unsupported type: ")
        builder:write(self.type)
        builder:write("\n")
    end
    return builder:promote()
end

-- Used to pretty print vectors of blocks
local function stringify_blocks(in_block: vector(block)): string
    local builder: stringbuilder
    for i=0,<#in_block do
        builder:write("Element ")
        builder:write(string.format("%06i", i))
        builder:write(" ;")
        builder:write(in_block[i])
    end
    return builder:promote()
end

-- From a pure file block, do the work to make a proper block
local function make_pure_file_block(in_block: pure_file_block): block
    local ret: block
    ret.type = block_types.pure_file
    ret.content.pure_file = in_block
    return ret
end

-- Delete the i-th block in a vector
local function delete_block(in_block: vector(block), i: integer)
    local ret: vector(block)
    for j=0,<#in_block do
        if j ~= i then
            ret:push(in_block[j])
        end
    end
    return ret
end

-- Add the new block at index i in the vector
local function insert_block(in_block: vector(block), i: integer, new: block)
    local ret: vector(block)
    for j=0,<#in_block do
        if j == i then
            ret:push(new)
        end
        ret:push(in_block[j])
    end
    return ret
end

-- Replace the block at index i in the vector with the new block
local function insert_block(in_block: vector(block), i: integer, new: block)
    local ret: vector(block)
    for j=0,<#in_block do
        if j == i then
            ret:push(new)
        end
        ret:push(in_block[j])
    end
    return ret
end
-- Replace a line in a file with a whole block
-- Useful to replace a directive with its effects
local function insert_block_in_file(in_block: vector(block), file_index: integer, line: integer, new_block: block): vector(block)
    local ret: vector(block)
    for i=0,<file_index do
        ret:push(in_block[i])
    end
    if #in_block[file_index].content.pure_file.content == 1 then
        ret:push(new_block)
    else
        local start_file = in_block[file_index].content.pure_file.content:sub(0,line-1)
        local end_file = in_block[file_index].content.pure_file.content:sub(line+1,#in_block[file_index].content.pure_file.content - 1)
        local start_block: pure_file_block = {start_file, in_block[file_index].content.pure_file.name, in_block[file_index].content.pure_file.place}
        local end_block: pure_file_block = {end_file, in_block[file_index].content.pure_file.name, in_block[file_index].content.pure_file.place+line+1}
        ret:push(make_pure_file_block(start_block))
        ret:push(new_block)
        ret:push(make_pure_file_block(end_block))
    end
    for i=file_index+1,<#in_block do
        ret:push(in_block[i])
    end
    return ret
end

----------------------------------- First step ---------------------------------

--Open a file as a pure_file_block
local function open_file_block(filename: string): (pure_file_block, error_t)
    local ret: pure_file_block
    local f, msg, err = io.open(filename, "r")
    if err ~= 0 then
        return ret, error_t.file_read
    end
    ret.content = purify_file(f)
    ret.name = filename
    ret.place = 1
    return ret, error_t.OK
end

--Do the substitution in each pure_files
local function first_step(in_block: vector(block)) : (vector(block), error_t)
    local ret = in_block:copy()
    for i=0,<#in_block do
        if in_block[i].type == block_types.pure_file then
            local file = in_block[i].content.pure_file.content
            for j=0,<#file do
                local line = file[j]
                if #line == 0 then
                    continue
                end
                if line[0] == "@import" then
                    if #line ~= 2 then
                        io.stderr:write("Error, invalid number of arguments for an import directive.\n")
                        return ret, error_t.arguments
                    end
                    local imported_file, err = open_file_block(line[1])
                    if err ~= error_t.OK then
                        io.stderr:write("Error, unable to open ", line[1], ".\n")
                        return ret, err
                    end
                    ret = insert_block_in_file(ret, i, j, make_pure_file_block(imported_file))
                    local ret_block, ret_err = first_step(ret)
                    return ret_block, ret_err
                end
            end
        end
    end
    return ret, error_t.OK
end

----------------------------------- Second step --------------------------------

-- Remove directives in pure files
-- TODO: maybe clean up code with meta-programming
local function second_step(in_block: vector(block)) : (vector(block), error_t)
    local ret = in_block:copy()
    for i=0,<#ret do
        if ret[i].type == block_types.pure_file then
            local file = ret[i].content.pure_file.content
            for j=0,<#file do
                local line = file[j]
                if #line == 0 then
                    continue
                end
                if line[0] == "@define" then --TODO: hard one
                elseif is_macro(line[0]) then --TODO
                elseif line[0] == "@label" then
                    if #line ~= 2 then
                        io.stderr:write("Error, invalid number of arguments for a label directive.\n")
                        return ret, error_t.arguments
                    end
                    local lab_blk: label_block = {line[1], true}
                    local new_block: block
                    new_block.type = block_types.label
                    new_block.content.label = lab_blk
                    ret = insert_block_in_file(ret, i, j, new_block)
                    local ret_block, ret_err = second_step(ret)
                    return ret_block, ret_err
                elseif line[0] == "@labref" then
                    if #line ~= 2 then
                        io.stderr:write("Error, invalid number of arguments for a labref directive.\n")
                        return ret, error_t.arguments
                    end
                    local lab_blk: label_block = {line[1], false}
                    local new_block: block
                    new_block.type = block_types.label
                    new_block.content.label = lab_blk
                    ret = insert_block_in_file(ret, i, j, new_block)
                    local ret_block, ret_err = second_step(ret)
                    return ret_block, ret_err
                elseif line[0] == "@align" then
                    if #line ~= 2 then
                        io.stderr:write("Error, invalid number of arguments for a align directive.\n")
                        return ret, error_t.arguments
                    end
                    local lab_blk: alignment_directive_block  = {tointeger(line[1])}
                    local new_block: block
                    new_block.type = block_types.alignment_directive
                    new_block.content.alignment_directive = lab_blk
                    ret = insert_block_in_file(ret, i, j, new_block)
                    local ret_block, ret_err = second_step(ret)
                    return ret_block, ret_err
                elseif line[0] == "@constant" then --TODO: find way to manipulate floats
                elseif line[0] == "@rawbytes" then
                    if #line < 2 then
                        io.stderr:write("Error, invalid number of arguments for a rawbytes directive.\n")
                        return ret, error_t.arguments
                    end
                    local raws: vector(byte)
                    for i=1,<#line do
                        raws:push(tointeger(line[i], 16))
                    end
                    local lab_blk: rawbytes_block  = {raws}
                    local new_block: block
                    new_block.type = block_types.rawbytes
                    new_block.content.rawbytes = lab_blk
                    ret = insert_block_in_file(ret, i, j, new_block)
                    local ret_block, ret_err = second_step(ret)
                    return ret_block, ret_err
                end
            end
        end
    end
    return ret, error_t.OK
end

----------------------------------- Third step ---------------------------------

-- Replace fancy blocks with their simpler version
local function third_step(in_block: vector(block)) : (vector(block), error_t)
    local ret = in_block:copy()
    for i=0,<#in_block do
        if ret[i].type == block_types.pure_file then
            local file = ret[i].content.pure_file.content
            if #file == 0 then
                ret = delete_block(ret, i)
                local ret_block, ret_err = third_step(ret)
                return ret_block, ret_err
            else
                local code: vector(block)
                for j=0,<#file do
                    local line = file[j]
                    if #line == 0 then
                        continue
                    end
                    local mc, err, pretty = assemble_line(line)
                    if err ~= 0 then
                        io.stderr:write("Error, invalid instruction.", line, "\n")
                        return ret, error_t.instruction
                    end
                    local new_block: block
                    new_block.type = block_types.machine_code
                    new_block.content.machine_code = {mc, pretty}
                    code:push(new_block)
                end
                ret = delete_block(ret, i)
                for j=0,<#code do
                    ret = insert_block(ret, i+j, code[j])
                end
                local ret_block, ret_err = third_step(ret)
                return ret_block, ret_err
            end
        elseif ret[i].type == block_types.rawbytes then
            local content = ret[i].content.rawbytes.content
            ret = delete_block(ret, i)
            for j=0,<#content do
                local new_block: block
                new_block.type = block_types.rawbyte
                new_block.content.rawbyte = {content[j]}
                ret = insert_block(ret, i+j, new_block)
            end
            local ret_block, ret_err = third_step(ret)
            return ret_block, ret_err
        end
    end
    return ret, error_t.OK
end

----------------------------------- Fourth step --------------------------------

local function fourth_step(in_block: vector(block)) : (vector(block), error_t)
    local ret: vector(block)
    for i=0,<#in_block do
        if in_block[i].type == block_types.label or in_block[i].type == block_types.rawbyte then
            ret:push(in_block[i])
        elseif in_block[i].type == block_types.machine_code then
            local new_block: block
            new_block.type = block_types.rawbyte
            new_block.content.rawbyte = {in_block[i].content.machine_code.code & 0xFF} --Note: little endian
            ret:push(new_block)
            new_block.content.rawbyte = {(in_block[i].content.machine_code.code >> 8) & 0xFF}
            ret:push(new_block)
        elseif in_block[i].type == block_types.alignment_directive then
            local new_block: block
            new_block.type = block_types.rawbyte
            new_block.content.rawbyte = {0}
            while #ret % in_block[i].content.alignment_directive.byte_alignment ~= 0 do
                ret:push(new_block)
            end
        else
            io.stderr:write("Error, unexpected type (", in_block[i].type, ") in fourth step.\n")
            return ret, error_t.type
        end
    end
    return ret, error_t.OK
end

-------------------------------------- Test ------------------------------------

-- To delete in final product
global function asm_test()
    local including_file, err = open_file_block("./directives.asm")
    print(err)
    local mini_vector : vector(block)
    mini_vector:push(make_pure_file_block(including_file))
    print(stringify_blocks(mini_vector))
    local step1_vector = first_step(mini_vector)
    print(stringify_blocks(step1_vector))
    local step2_vector = second_step(step1_vector)
    print(stringify_blocks(step2_vector))
    local step3_vector = third_step(step2_vector)
    print(stringify_blocks(step3_vector))
    local step4_vector = fourth_step(step3_vector)
    print(stringify_blocks(step4_vector))
end
