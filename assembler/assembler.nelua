--[[--------------------------------------------
|This file contains the main loop of the       |
|assembling, reading a file, checking each     |
|line and either assemble them and process     |
|them like macro or other assembler directives.|
----------------------------------------------]]

--[[
During assembly, the output is represented as a list of assembling blocs.
An assembling block can either be:
    - A pure_file of assembly language associted with name and a start line. The name and start line are used to display error messages that tell the line and the file where the error come from.
    - A label being set or a reference to that label that needs to be computed.
    - A special assembler directive such as an allignement constrain.
    - An assembled instruction in machine code.
    - A raw binary constant

The first two steps of the compilation is to decode all pure_files in the list. The pure_files are processed line by line.

In the first step, the @import directives are extended into new pure_files, the rest of the assembly code is packed into other pure_files. This steps is repeaded until there is no longuer any @import directives.

The second step is to process other directives
- @define ... @end directives are registred as macro.
- Macro are expended into pure_files.
- @label and @labref are registered
- @allign are reregestered
- @string and @rawbytes are registered as such
This step is repeted until there is no longuer any pure_files in the list of blocs

The third step is to replace all the blocs whose size are not known yet (allignement dirrectives) with blocks of padding whose size is known.

As the fourth step, when the address of everythin can be known, a linking can be done by replacing @labref whith raw constants. Furthermore, @label can be checked to ensure that there is no duplicates.

Lastly, the fifth step is to write the output binary file.

]]

require 'io'
require 'vector'
require 'parser'
require 'filestream'
require 'stringbuilder'

----------------------------------Data types------------------------------------

local error_t = @enum {
    OK = 0,
    file_read,
    file_write,
    arguments
}

local block_types = @enum {
    pure_file = 1,
    machine_code,
    allignement_directive,
    padding,
    rawbyte,
    rawbytes,
    label
}

local pure_file_block = @record {
    content: pure_file,
    name: string,
    place: integer
}

local machine_code_block = @record {
    code: uint16,
    comment: string
}

local allignement_directive_block = @record {
    byte_allignement: integer
}

local padding_block = @record {
    number_of_bytes: integer
}

local rawbyte_block = @record {
    content: byte
}

local rawbytes_block = @record {
    content: vector(byte)
}

local label_block = @record {
    id: string,
    set: boolean
}

local block_union = @union {
    pure_file: pure_file_block,
    machine_code: machine_code_block,
    allignement_directive: allignement_directive_block,
    padding: padding_block,
    rawbyte: rawbyte_block,
    rawbytes: rawbytes_block,
    label: label_block
}

local block = @record {
    type: block_types,
    content: block_union
}

function block:__tostring()
    local builder: stringbuilder
    if self.type == block_types.pure_file then
        builder:write("Type = pure_file\nFilename = ")
        builder:write(self.content.pure_file.name)
        builder:write(" ; place = ")
        builder:write(self.content.pure_file.place)
        builder:write(" ; content = [")
        builder:write(self.content.pure_file.content)
        builder:write("]\n")
    else
        builder:write("Unsuported type: ")
        builder:write(self.type)
        builder:write("\n")
    end
    return builder:promote()
end

local function stringify_blocks(in_block: vector(block)): string
    local builder: stringbuilder
    for i=0,<#in_block do
        builder:write("Element ")
        builder:write(i)
        builder:write(" ;")
        builder:write(in_block[i])
    end
    return builder:promote()
end

local function make_pure_file_block(in_block: pure_file_block): block
    local ret: block
    ret.type = block_types.pure_file
    ret.content.pure_file = in_block
    return ret
end

local function insert_block_in_file(in_block: vector(block), file_index: integer, line: integer, new_block: block): vector(block)
    print(stringify_blocks(in_block))
    local ret: vector(block)
    for i=0,<file_index do
        ret:push(in_block[i])
    end
    print("eee", file_index)
    if #in_block[file_index].content.pure_file.content == 1 then
        ret:push(new_block)
    else
        print("abc")
        local start_file = in_block[file_index].content.pure_file.content:sub(0,line-1)
        print("def")
        local end_file = in_block[file_index].content.pure_file.content:sub(line+1,#in_block[file_index].content.pure_file.content - 1)
        print("ghi")
        local start_block: pure_file_block = {start_file, in_block[file_index].content.pure_file.name, in_block[file_index].content.pure_file.place}
        print("jkl")
        local end_block: pure_file_block = {end_file, in_block[file_index].content.pure_file.name, in_block[file_index].content.pure_file.place+line+1}
        print("mno")
        ret:push(make_pure_file_block(start_block))
        ret:push(new_block)
        ret:push(make_pure_file_block(end_block))
    end
    print("fff")
    for i=file_index+1,<#in_block do
        ret:push(in_block[i])
    end
    print("ggg")
    return ret
end

----------------------------------First step------------------------------------

--Open a file as a pure_file_block
local function open_file_block(filename: string): (pure_file_block, error_t)
    local ret: pure_file_block
    local f, msg, err = io.open(filename, "r")
    if err ~= 0 then
        return ret, error_t.file_read
    end
    ret.content = purify_file(f)
    ret.name = filename
    ret.place = 1
    return ret, error_t.OK
end

--Do the substiturion in each pure_files
local function first_step(in_block: vector(block)) : (vector(block), error_t) --TODO: remove global
    local ret = in_block:copy()
    local made_substitutions = false
    for i=0,<#in_block do
        if in_block[i].type == block_types.pure_file then
            local file = in_block[i].content.pure_file.content
            for j=0,<#file do
                local line = file[j]
                if line[0] == "@import" then
                    print("Doing it")
                    if #line ~= 2 then
                        io.stderr:write("Error, invalid number of arguments for an import directive.\n")
                        return ret, error_t.arguments
                    end
                    local imported_file, err = open_file_block(line[1])
                    if err ~= error_t.OK then
                        io.stderr:write("Error, unable to open ", line[1], ".\n")
                        return ret, err
                    end
                    print("ii")
                    ret = insert_block_in_file(ret, i, j, make_pure_file_block(imported_file))
                    print("ii")
                    made_substitutions = true
                end
            end
        end
    end
    if made_substitutions then
        return first_step(ret)
    else
        return ret, error_t.OK
    end
end

global function including_test()
    local including_file, err = open_file_block("test_inc.asm")
    print(err)
    local mini_vector : vector(block)
    mini_vector:push(make_pure_file_block(including_file))
    print(stringify_blocks(mini_vector))
    local new_vector = first_step(mini_vector)
    print(stringify_blocks(new_vector))
end

